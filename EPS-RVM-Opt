import numpy as np
import matplotlib.pyplot as plt
from scipy.spatial import ConvexHull
from openpyxl import load_workbook
import matplotlib.font_manager as fm
from matplotlib.colors import LinearSegmentedColormap

# Set fonts (prefer Microsoft YaHei, fallback Source Han Sans CN) â€” kept for robustness
available_fonts = [f.name for f in fm.fontManager.ttflist]
if 'Microsoft YaHei' in available_fonts:
    plt.rcParams['font.sans-serif'] = ['Microsoft YaHei']
elif 'Source Han Sans CN' in available_fonts:
    plt.rcParams['font.sans-serif'] = ['Source Han Sans CN']
else:
    print("Warning: Microsoft YaHei or Source Han Sans CN not found. Using default font, which may not display CJK characters properly.")
plt.rcParams['axes.unicode_minus'] = False  # Fix minus sign rendering

# Load Times New Roman (fallback DejaVu Serif)
if 'Times New Roman' in available_fonts:
    times_font = fm.FontProperties(family='Times New Roman')
else:
    times_font = fm.FontProperties(family='DejaVu Serif')
    print("Warning: Times New Roman not found. Using DejaVu Serif as fallback.")

# Check whether a point is inside the convex hull (ray casting)
def is_point_inside_hull(point, hull):
    n_intersections = 0
    n = len(hull.vertices)
    x, y = point

    for i in range(n):
        v1 = hull.points[hull.vertices[i]]
        v2 = hull.points[hull.vertices[(i + 1) % n]]
        if (v1[1] > y) != (v2[1] > y):
            if x < (v2[0] - v1[0]) * (y - v1[1]) / (v2[1] - v1[1]) + v1[0]:
                n_intersections += 1
    return n_intersections % 2 == 1

# Load Excel data
def load_data(file_path):
    wb = load_workbook(file_path)
    ws = wb.active
    f1_data = []
    f2_data = []
    for row in ws.iter_rows(min_row=2, values_only=True):
        f1_data.append(row[5])  # original: column index 5
        f2_data.append(row[4])  # original: column index 4
    return np.column_stack((f1_data, f2_data))

# Plot scatter and convex hull
def plot_convex_hull(points):
    if len(points) < 3:
        raise ValueError("Insufficient points to compute a convex hull (need at least 3).")

    # Figure and axis
    fig, ax = plt.subplots(figsize=(10, 8), dpi=100)

    # Compute convex hull
    hull = ConvexHull(points)
    hull_vertices = hull.vertices
    exterior_points = points[hull_vertices]

    # Custom gradient colormap
    cmap = LinearSegmentedColormap.from_list('custom', ['#1E90FF', '#00CED1'])

    # Hull filled polygon (semi-transparent gradient-like effect)
    hull_polygon = plt.Polygon(
        exterior_points,
        closed=True,
        facecolor=cmap(0.3),
        alpha=0.3,
        edgecolor='none',
        zorder=1
    )
    ax.add_patch(hull_polygon)

    # Hull edges
    for simplex in hull.simplices:
        ax.plot(
            points[simplex, 0],
            points[simplex, 1],
            color='#8B0000',
            linewidth=2.5,
            linestyle='-',
            zorder=3,
            label='Boundary range of the objective space'
                  if 'Boundary range of the objective space' not in [l.get_label() for l in ax.get_lines()]
                  else ""
        )

    # Hull vertices (with gradient sizes and colors)
    sizes = np.linspace(100, 200, len(exterior_points))
    colors = [cmap(i / len(exterior_points)) for i in range(len(exterior_points))]
    ax.scatter(
        exterior_points[:, 0],
        exterior_points[:, 1],
        c=colors,
        s=sizes,
        edgecolor='black',
        linewidth=0.8,
        alpha=0.9,
        label='Boundary points of the objective space',
        zorder=5
    )

    # Grid and axes lines
    ax.grid(True, linestyle='--', color='gray', alpha=0.4, zorder=0)
    ax.axhline(0, color='black', linewidth=1, zorder=2)
    ax.axvline(0, color='black', linewidth=1, zorder=2)

    # English title and labels
    ax.set_title('Convex Hull of Objective Space', fontsize=20, pad=15, fontweight='bold')
    ax.set_xlabel('F1 Axis', fontsize=16, labelpad=10, fontproperties=times_font)
    ax.set_ylabel('F2 Axis', fontsize=16, labelpad=10, fontproperties=times_font)

    # Legend
    ax.legend(
        loc='upper right',
        fontsize=30,
        frameon=True,
        framealpha=0.9,
        edgecolor='black',
        facecolor='white',
        prop=times_font
    )

    # Axis ranges
    ax.set_xlim(0, 50)
    ax.set_ylim(bottom=0)

    # Tick styling
    ax.tick_params(axis='both', which='major', labelsize=18, labelcolor='black')
    for label in ax.get_xticklabels() + ax.get_yticklabels():
        label.set_fontproperties(times_font)

    # Backgrounds
    fig.patch.set_facecolor('white')
    ax.set_facecolor('#F8F9FA')

    # Layout
    plt.tight_layout()

    # Show
    plt.show()

    # Count interior points
    interior_points = []
    all_indices = set(range(len(points)))
    hull_indices = set(hull_vertices)
    remaining_indices = all_indices - hull_indices

    for idx in remaining_indices:
        if is_point_inside_hull(points[idx], hull):
            interior_points.append(points[idx])

    interior_points = np.array(interior_points) if interior_points else np.array([])
    return hull, interior_points

# Main
if __name__ == "__main__":
    file_path = "C:\\Users\\ASUS\\Desktop\\optimization_results.xlsx"
    print("Loading data...")
    points = load_data(file_path)
    print(f"Successfully loaded {len(points)} points.")

    print("Plotting scatter and computing convex hull...")
    hull, interior_points = plot_convex_hull(points)
    print(f"Found {len(interior_points)} interior points (not displayed).")
    print(f"Displayed {len(hull.vertices)} points on the convex hull.")
    print("Done.")

import pandas as pd
from pyomo.environ import *
import numpy as np
import math

excel_path = 'your_excel_file.xlsx'  # please set your Excel path
data = pd.read_excel(excel_path)

# English reservoir names
reservoirs = ['Hongze', 'Luoma', 'Xiaji', 'Shangji', 'Dongping']
reservoir_names = ['Hongze', 'Luoma', 'Xiaji', 'Shangji', 'Dongping']

# English Excel column names (make sure your Excel file uses these)
initial_storage = dict(zip(reservoirs, data['Initial_Storage'].values))
inflow = {res: data[f'{res}_Inflow'].values for res in reservoirs}
water_demand = {res: data[f'{res}_Demand'].values for res in reservoirs}
upper_limit = {res: data[f'{res}_UpperLimit'].values for res in reservoirs}
lower_limit = {res: data[f'{res}_LowerLimit'].values for res in reservoirs}
local_transfer_limit = {res: data[f'{res}_LocalLimit'].values for res in reservoirs}
ecological_storage = {res: data[f'{res}_EcoStorage'].values for res in reservoirs}
total_source_limit = data['Total_Source_Limit'].values[0]
total_waste_limit = data['Total_Waste_Limit'].values[0]

months = range(12)
results = []


# ----- Objective functions -----
def obj1_rule(model):
    total_shortage = sum(
        ((water_demand[res][m] - model.supply[res, m]) / water_demand[res][m]) ** 2
        for res in reservoirs for m in months if water_demand[res][m] > 0
    )
    return total_shortage / (len(reservoirs) * len(months)) * 100


def obj2_rule(model):
    return sum(model.source_flow[m] for m in months)


model.obj = Objective(rule=combined_obj_rule, sense=minimize if sense == 'minimize' else maximize)


# ----- Water balance constraints -----
def water_balance_rule(model, res, m):
    if res == 'Dongping':
        if m == 0:
            return model.storage[res, m] == initial_storage[res] + inflow[res][m] + model.inflow_transfer[res, m] - model.supply[res, m] - model.waste[res, m]
        else:
            return model.storage[res, m] == model.storage[res, m - 1] + inflow[res][m] + model.inflow_transfer[res, m] - model.supply[res, m] - model.waste[res, m]
    else:
        if m == 0:
            return model.storage[res, m] == initial_storage[res] + inflow[res][m] + model.inflow_transfer[res, m] - model.supply[res, m] - model.outflow_transfer[res, m] - model.waste[res, m]
        else:
            return model.storage[res, m] == model.storage[res, m - 1] + inflow[res][m] + model.inflow_transfer[res, m] - model.supply[res, m] - model.outflow_transfer[res, m] - model.waste[res, m]


model.water_balance = Constraint(reservoirs, months, rule=water_balance_rule)


# ----- Storage limits -----
def storage_upper_limit_rule(model, res, m):
    return model.storage[res, m] <= upper_limit[res][m]


def storage_lower_limit_rule(model, res, m):
    return model.storage[res, m] >= lower_limit[res][m]


model.storage_upper_limit = Constraint(reservoirs, months, rule=storage_upper_limit_rule)
model.storage_lower_limit = Constraint(reservoirs, months, rule=storage_lower_limit_rule)


# ----- Supply limit -----
def supply_limit_rule(model, res, m):
    return model.supply[res, m] <= water_demand[res][m]


model.supply_limit = Constraint(reservoirs, months, rule=supply_limit_rule)


# ----- End storage constraint -----
def initial_final_storage_rule(model, res):
    return model.storage[res, 11] == initial_storage[res]


model.initial_final_storage = Constraint(reservoirs, rule=initial_final_storage_rule)


# ----- Local transfer limit -----
def local_transfer_limit_rule(model, res, m):
    return model.outflow_transfer[res, m] - model.inflow_transfer[res, m] <= local_transfer_limit[res][m]


model.local_transfer_limit = Constraint([res for res in reservoirs if res != 'Dongping'], months, rule=local_transfer_limit_rule)


# ----- Hydraulic transfer -----
def hydraulic_transfer_rule(model, res, m):
    if res == 'Hongze':
        return model.inflow_transfer[res, m] == model.source_flow[m]
    else:
        prev_res = reservoirs[reservoirs.index(res) - 1]
        if prev_res == 'Dongping':
            return Constraint.Skip
        return model.inflow_transfer[res, m] == model.outflow_transfer[prev_res, m]


model.hydraulic_transfer = Constraint(reservoirs, months, rule=hydraulic_transfer_rule)


# ----- Total limits -----
def total_source_flow_limit_rule(model):
    return sum(model.source_flow[m] for m in months) <= total_source_limit


model.total_source_flow_limit = Constraint(rule=total_source_flow_limit_rule)


def total_waste_limit_rule(model):
    return sum(model.waste[res, m] for res in reservoirs for m in months) <= total_waste_limit


model.total_waste_limit = Constraint(rule=total_waste_limit_rule)

import pandas as pd
from pyomo.environ import *
import numpy as np
import math

data = pd.read_excel(excel_path)

reservoirs = ['Hongze', 'Luoma', 'Xiaji', 'Shangji', 'Dongping']
reservoir_names = ['Hongze', 'Luoma', 'Xiaji', 'Shangji', 'Dongping']

# Column names changed to English equivalents
initial_storage = dict(zip(reservoirs, data['Initial_Storage'].values))
inflow = {res: data[f'{res}_Inflow'].values for res in reservoirs}
water_demand = {res: data[f'{res}_Demand'].values for res in reservoirs}
upper_limit = {res: data[f'{res}_UpperLimit'].values for res in reservoirs}
lower_limit = {res: data[f'{res}_LowerLimit'].values for res in reservoirs}
local_transfer_limit = {res: data[f'{res}_LocalLimit'].values for res in reservoirs}
ecological_storage = {res: data[f'{res}_EcoStorage'].values for res in reservoirs}
total_source_limit = data['Total_Source_Limit'].values[0]
total_waste_limit = data['Total_Waste_Limit'].values[0]

months = range(12)
results = []
angles = list(range(1, 90)) + list(range(91, 181))

for theta in angles:
    for sense in ['minimize', 'maximize']:

        model = ConcreteModel()

        model.source_flow = Var(months, domain=NonNegativeReals)
        model.storage = Var(reservoirs, months, domain=NonNegativeReals)
        model.supply = Var(reservoirs, months, domain=NonNegativeReals)
        model.waste = Var(reservoirs, months, domain=NonNegativeReals)
        model.inflow_transfer = Var(reservoirs, months, domain=NonNegativeReals)
        model.outflow_transfer = Var([res for res in reservoirs if res != 'Dongping'], months, domain=NonNegativeReals)

        def obj1_rule(model):
            total_shortage = sum(
                ((water_demand[res][m] - model.supply[res, m]) / water_demand[res][m]) ** 2
                for res in reservoirs for m in months if water_demand[res][m] > 0
            )
            return total_shortage / (len(reservoirs) * len(months)) * 100

        def obj2_rule(model):
            return sum(model.source_flow[m] for m in months)

        w1 = math.tan(math.radians(theta))  # w1/w2 = tan(theta), set w2=1
        w2 = 1.0

        def combined_obj_rule(model):
            return w1 * obj1_rule(model) + w2 * obj2_rule(model)

        model.obj = Objective(rule=combined_obj_rule, sense=minimize if sense == 'minimize' else maximize)

        def water_balance_rule(model, res, m):
            if res == 'Dongping':
                if m == 0:
                    return model.storage[res, m] == initial_storage[res] + inflow[res][m] + model.inflow_transfer[res, m] - model.supply[res, m] - model.waste[res, m]
                else:
                    return model.storage[res, m] == model.storage[res, m-1] + inflow[res][m] + model.inflow_transfer[res, m] - model.supply[res, m] - model.waste[res, m]
            else:
                if m == 0:
                    return model.storage[res, m] == initial_storage[res] + inflow[res][m] + model.inflow_transfer[res, m] - model.supply[res, m] - model.outflow_transfer[res, m] - model.waste[res, m]
                else:
                    return model.storage[res, m] == model.storage[res, m-1] + inflow[res][m] + model.inflow_transfer[res, m] - model.supply[res, m] - model.outflow_transfer[res, m] - model.waste[res, m]

        model.water_balance = Constraint(reservoirs, months, rule=water_balance_rule)

        def storage_upper_limit_rule(model, res, m):
            return model.storage[res, m] <= upper_limit[res][m]

        def storage_lower_limit_rule(model, res, m):
            return model.storage[res, m] >= lower_limit[res][m]

        model.storage_upper_limit = Constraint(reservoirs, months, rule=storage_upper_limit_rule)
        model.storage_lower_limit = Constraint(reservoirs, months, rule=storage_lower_limit_rule)

        def supply_limit_rule(model, res, m):
            return model.supply[res, m] <= water_demand[res][m]

        model.supply_limit = Constraint(reservoirs, months, rule=supply_limit_rule)

        def initial_final_storage_rule(model, res):
            return model.storage[res, 11] == initial_storage[res]

        model.initial_final_storage = Constraint(reservoirs, rule=initial_final_storage_rule)

        def local_transfer_limit_rule(model, res, m):
            return model.outflow_transfer[res, m] - model.inflow_transfer[res, m] <= local_transfer_limit[res][m]

        model.local_transfer_limit = Constraint([res for res in reservoirs if res != 'Dongping'], months, rule=local_transfer_limit_rule)

        def hydraulic_transfer_rule(model, res, m):
            if res == 'Hongze':
                return model.inflow_transfer[res, m] == model.source_flow[m]
            else:
                prev_res = reservoirs[reservoirs.index(res) - 1]
                if prev_res == 'Dongping':
                    return Constraint.Skip
                return model.inflow_transfer[res, m] == model.outflow_transfer[prev_res, m]

        model.hydraulic_transfer = Constraint(reservoirs, months, rule=hydraulic_transfer_rule)

        def total_source_flow_limit_rule(model):
            return sum(model.source_flow[m] for m in months) <= total_source_limit

        model.total_source_flow_limit = Constraint(rule=total_source_flow_limit_rule)

        def total_waste_limit_rule(model):
            return sum(model.waste[res, m] for res in reservoirs for m in months) <= total_waste_limit

        model.total_waste_limit = Constraint(rule=total_waste_limit_rule)

        solver = SolverFactory('ipopt')
        solver.options['tol'] = 1e-8
        results_solver = solver.solve(model, tee=False)

        result = {
            'Angle (deg)': theta,
            'w1': round(w1, 2),
            'w2': round(w2, 2),
            'Direction': sense,
            'f1 (%)': None,
            'f2 (10^8 mÂ³)': None,
            'f': None
        }

        if results_solver.solver.status == SolverStatus.ok and results_solver.solver.termination_condition == TerminationCondition.optimal:
            f1_value = value(obj1_rule(model))
            f2_value = value(obj2_rule(model))
            f_value = w1 * f1_value + w2 * f2_value

            result['f1 (%)'] = round(f1_value, 2)
            result['f2 (10^8 mÂ³)'] = round(f2_value, 2)
            result['f'] = round(f_value, 2)

            print(f"\nAngle: {theta}Â°, Direction: {sense}")
            print(f"f1 (Water Shortage Rate, %): {f1_value:.2f}")
            print(f"f2 (Total Source Flow): {f2_value:.2f}")

            for m in months:
                result[f'S{m+1}'] = round(model.source_flow[m].value, 2)

            for i, res in enumerate(reservoirs):
                for m in months:
                    result[f'{reservoir_names[i]}_S{m+1}'] = round(model.storage[res, m].value, 2)

            for i, res in enumerate(reservoirs):
                for m in months:
                    result[f'{reservoir_names[i]}_Q{m+1}'] = round(model.supply[res, m].value, 2)

            for i, res in enumerate(reservoirs):
                for m in months:
                    result[f'{reservoir_names[i]}_W{m+1}'] = round(model.waste[res, m].value, 2)

            for i, res in enumerate(reservoirs):
                for m in months:
                    result[f'{reservoir_names[i]}_Tin{m+1}'] = round(model.inflow_transfer[res, m].value, 2)

            for i, res in enumerate(reservoirs):
                if res != 'Dongping':
                    for m in months:
                        result[f'{reservoir_names[i]}_Tout{m+1}'] = round(model.outflow_transfer[res, m].value, 2)
                else:
                    for m in months:
                        result[f'{reservoir_names[i]}_Tout{m+1}'] = None  # Dongping has no outflow_transfer

            error_found = False
            for res in reservoirs:
                for m in months:
                    storage_actual = model.storage[res, m].value
                    if m == 0:
                        storage_prev = initial_storage[res]
                    else:
                        storage_prev = model.storage[res, m-1].value
                    if res == 'Dongping':
                        expected = (
                            storage_prev +
                            inflow[res][m] +
                            model.inflow_transfer[res, m].value -
                            model.supply[res, m].value -
                            model.waste[res, m].value
                        )
                    else:
                        expected = (
                            storage_prev +
                            inflow[res][m] +
                            model.inflow_transfer[res, m].value -
                            model.supply[res, m].value -
                            model.outflow_transfer[res, m].value -
                            model.waste[res, m].value
                        )
                    error = storage_actual - expected if storage_actual is not None else float('inf')
                    if abs(error) > 1e-6:
                        error_found = True
                        print(f"Water balance error - {res}, Month {m+1}: actual={storage_actual:.4f}, expected={expected:.4f}, error={error:.6f}")
            if error_found:
                print("Warning: Water balance error detected!")
        else:
            print(f"\nAngle: {theta}Â°, Direction: {sense} - Solve failed!")
            print(f"Solver status: {results_solver.solver.status}")
            print(f"Termination condition: {results_solver.solver.termination_condition}")

            for m in months:
                result[f'S{m+1}'] = None
            for i, res in enumerate(reservoirs):
                for m in months:
                    result[f'{reservoir_names[i]}_S{m+1}'] = None
                    result[f'{reservoir_names[i]}_Q{m+1}'] = None
                    result[f'{reservoir_names[i]}_W{m+1}'] = None
                    result[f'{reservoir_names[i]}_Tin{m+1}'] = None
                    result[f'{reservoir_names[i]}_Eco{m+1}'] = None
                    result[f'{reservoir_names[i]}_Tout{m+1}'] = None

        results.append(result)

results_df = pd.DataFrame(results)
results_df.to_excel('optimization_results.xlsx', index=False)
print("\nResults saved to optimization_results.xlsx")
