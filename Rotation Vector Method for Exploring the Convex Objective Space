import pandas as pd
from pyomo.environ import *
import numpy as np
import math

data = pd.read_excel(excel_path)

reservoirs = ['Hongze', 'Luoma', 'Xiaji', 'Shangji', 'Dongping']
reservoir_names = ['Hongze', 'Luoma', 'Xiaji', 'Shangji', 'Dongping']

# Column names changed to English equivalents
initial_storage = dict(zip(reservoirs, data['Initial_Storage'].values))
inflow = {res: data[f'{res}_Inflow'].values for res in reservoirs}
water_demand = {res: data[f'{res}_Demand'].values for res in reservoirs}
upper_limit = {res: data[f'{res}_UpperLimit'].values for res in reservoirs}
lower_limit = {res: data[f'{res}_LowerLimit'].values for res in reservoirs}
local_transfer_limit = {res: data[f'{res}_LocalLimit'].values for res in reservoirs}
ecological_storage = {res: data[f'{res}_EcoStorage'].values for res in reservoirs}
total_source_limit = data['Total_Source_Limit'].values[0]
total_waste_limit = data['Total_Waste_Limit'].values[0]

months = range(12)
results = []
angles = list(range(1, 90)) + list(range(91, 181))

for theta in angles:
    for sense in ['minimize', 'maximize']:

        model = ConcreteModel()

        model.source_flow = Var(months, domain=NonNegativeReals)
        model.storage = Var(reservoirs, months, domain=NonNegativeReals)
        model.supply = Var(reservoirs, months, domain=NonNegativeReals)
        model.waste = Var(reservoirs, months, domain=NonNegativeReals)
        model.inflow_transfer = Var(reservoirs, months, domain=NonNegativeReals)
        model.outflow_transfer = Var([res for res in reservoirs if res != 'Dongping'], months, domain=NonNegativeReals)

        def obj1_rule(model):
            total_shortage = sum(
                ((water_demand[res][m] - model.supply[res, m]) / water_demand[res][m]) ** 2
                for res in reservoirs for m in months if water_demand[res][m] > 0
            )
            return total_shortage / (len(reservoirs) * len(months)) * 100

        def obj2_rule(model):
            return sum(model.source_flow[m] for m in months)

        w1 = math.tan(math.radians(theta))  # w1/w2 = tan(theta), set w2=1
        w2 = 1.0

        def combined_obj_rule(model):
            return w1 * obj1_rule(model) + w2 * obj2_rule(model)

        model.obj = Objective(rule=combined_obj_rule, sense=minimize if sense == 'minimize' else maximize)

        def water_balance_rule(model, res, m):
            if res == 'Dongping':
                if m == 0:
                    return model.storage[res, m] == initial_storage[res] + inflow[res][m] + model.inflow_transfer[res, m] - model.supply[res, m] - model.waste[res, m]
                else:
                    return model.storage[res, m] == model.storage[res, m-1] + inflow[res][m] + model.inflow_transfer[res, m] - model.supply[res, m] - model.waste[res, m]
            else:
                if m == 0:
                    return model.storage[res, m] == initial_storage[res] + inflow[res][m] + model.inflow_transfer[res, m] - model.supply[res, m] - model.outflow_transfer[res, m] - model.waste[res, m]
                else:
                    return model.storage[res, m] == model.storage[res, m-1] + inflow[res][m] + model.inflow_transfer[res, m] - model.supply[res, m] - model.outflow_transfer[res, m] - model.waste[res, m]

        model.water_balance = Constraint(reservoirs, months, rule=water_balance_rule)

        def storage_upper_limit_rule(model, res, m):
            return model.storage[res, m] <= upper_limit[res][m]

        def storage_lower_limit_rule(model, res, m):
            return model.storage[res, m] >= lower_limit[res][m]

        model.storage_upper_limit = Constraint(reservoirs, months, rule=storage_upper_limit_rule)
        model.storage_lower_limit = Constraint(reservoirs, months, rule=storage_lower_limit_rule)

        def supply_limit_rule(model, res, m):
            return model.supply[res, m] <= water_demand[res][m]

        model.supply_limit = Constraint(reservoirs, months, rule=supply_limit_rule)

        def initial_final_storage_rule(model, res):
            return model.storage[res, 11] == initial_storage[res]

        model.initial_final_storage = Constraint(reservoirs, rule=initial_final_storage_rule)

        def local_transfer_limit_rule(model, res, m):
            return model.outflow_transfer[res, m] - model.inflow_transfer[res, m] <= local_transfer_limit[res][m]

        model.local_transfer_limit = Constraint([res for res in reservoirs if res != 'Dongping'], months, rule=local_transfer_limit_rule)

        def hydraulic_transfer_rule(model, res, m):
            if res == 'Hongze':
                return model.inflow_transfer[res, m] == model.source_flow[m]
            else:
                prev_res = reservoirs[reservoirs.index(res) - 1]
                if prev_res == 'Dongping':
                    return Constraint.Skip
                return model.inflow_transfer[res, m] == model.outflow_transfer[prev_res, m]

        model.hydraulic_transfer = Constraint(reservoirs, months, rule=hydraulic_transfer_rule)

        def total_source_flow_limit_rule(model):
            return sum(model.source_flow[m] for m in months) <= total_source_limit

        model.total_source_flow_limit = Constraint(rule=total_source_flow_limit_rule)

        def total_waste_limit_rule(model):
            return sum(model.waste[res, m] for res in reservoirs for m in months) <= total_waste_limit

        model.total_waste_limit = Constraint(rule=total_waste_limit_rule)

        solver = SolverFactory('ipopt')
        solver.options['tol'] = 1e-8
        results_solver = solver.solve(model, tee=False)

        result = {
            'Angle (deg)': theta,
            'w1': round(w1, 2),
            'w2': round(w2, 2),
            'Direction': sense,
            'f1 (%)': None,
            'f2 (10^8 m³)': None,
            'f': None
        }

        if results_solver.solver.status == SolverStatus.ok and results_solver.solver.termination_condition == TerminationCondition.optimal:
            f1_value = value(obj1_rule(model))
            f2_value = value(obj2_rule(model))
            f_value = w1 * f1_value + w2 * f2_value

            result['f1 (%)'] = round(f1_value, 2)
            result['f2 (10^8 m³)'] = round(f2_value, 2)
            result['f'] = round(f_value, 2)

            print(f"\nAngle: {theta}°, Direction: {sense}")
            print(f"f1 (Water Shortage Rate, %): {f1_value:.2f}")
            print(f"f2 (Total Source Flow): {f2_value:.2f}")

            for m in months:
                result[f'S{m+1}'] = round(model.source_flow[m].value, 2)

            for i, res in enumerate(reservoirs):
                for m in months:
                    result[f'{reservoir_names[i]}_S{m+1}'] = round(model.storage[res, m].value, 2)

            for i, res in enumerate(reservoirs):
                for m in months:
                    result[f'{reservoir_names[i]}_Q{m+1}'] = round(model.supply[res, m].value, 2)

            for i, res in enumerate(reservoirs):
                for m in months:
                    result[f'{reservoir_names[i]}_W{m+1}'] = round(model.waste[res, m].value, 2)

            for i, res in enumerate(reservoirs):
                for m in months:
                    result[f'{reservoir_names[i]}_Tin{m+1}'] = round(model.inflow_transfer[res, m].value, 2)

            for i, res in enumerate(reservoirs):
                if res != 'Dongping':
                    for m in months:
                        result[f'{reservoir_names[i]}_Tout{m+1}'] = round(model.outflow_transfer[res, m].value, 2)
                else:
                    for m in months:
                        result[f'{reservoir_names[i]}_Tout{m+1}'] = None  # Dongping has no outflow_transfer

            error_found = False
            for res in reservoirs:
                for m in months:
                    storage_actual = model.storage[res, m].value
                    if m == 0:
                        storage_prev = initial_storage[res]
                    else:
                        storage_prev = model.storage[res, m-1].value
                    if res == 'Dongping':
                        expected = (
                            storage_prev +
                            inflow[res][m] +
                            model.inflow_transfer[res, m].value -
                            model.supply[res, m].value -
                            model.waste[res, m].value
                        )
                    else:
                        expected = (
                            storage_prev +
                            inflow[res][m] +
                            model.inflow_transfer[res, m].value -
                            model.supply[res, m].value -
                            model.outflow_transfer[res, m].value -
                            model.waste[res, m].value
                        )
                    error = storage_actual - expected if storage_actual is not None else float('inf')
                    if abs(error) > 1e-6:
                        error_found = True
                        print(f"Water balance error - {res}, Month {m+1}: actual={storage_actual:.4f}, expected={expected:.4f}, error={error:.6f}")
            if error_found:
                print("Warning: Water balance error detected!")
        else:
            print(f"\nAngle: {theta}°, Direction: {sense} - Solve failed!")
            print(f"Solver status: {results_solver.solver.status}")
            print(f"Termination condition: {results_solver.solver.termination_condition}")

            for m in months:
                result[f'S{m+1}'] = None
            for i, res in enumerate(reservoirs):
                for m in months:
                    result[f'{reservoir_names[i]}_S{m+1}'] = None
                    result[f'{reservoir_names[i]}_Q{m+1}'] = None
                    result[f'{reservoir_names[i]}_W{m+1}'] = None
                    result[f'{reservoir_names[i]}_Tin{m+1}'] = None
                    result[f'{reservoir_names[i]}_Eco{m+1}'] = None
                    result[f'{reservoir_names[i]}_Tout{m+1}'] = None

        results.append(result)

results_df = pd.DataFrame(results)
results_df.to_excel('optimization_results.xlsx', index=False)
print("\nResults saved to optimization_results.xlsx")

